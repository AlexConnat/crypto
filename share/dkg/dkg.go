package vss

import (
	"bytes"
	"crypto/cipher"
	"encoding/binary"
	"errors"

	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/share"
	"github.com/dedis/crypto/share/vss"
	"github.com/dedis/crypto/sign"
)

type DistKeyShare struct {

	// Commitments is the list of commitment of the coefficient of the private
	// polynomial. The Share can be verified against of this list of
	// commitments. The first element is the distributed public key.
	Commitments []abstract.Point

	// share of the distributed secret
	Share abstract.Scalar

	// index of the participant holding this share
	Index int
}

// Public returns the distributed public key generated.
func (dks *DistKeyShare) Public() abstract.Point {
	return dks.Commitments[0]
}

// DistDeal is a simple wrapper around Deal used to provide the index of the
// Dealer in the list of participants together with its Deal.
// NOTE: Doing that in vss.go would be possible but then the Dealer is always
// assumed to be a member of the participants. It's only the case here.
type Deal struct {
	// Index of the Dealer in the list of participants
	Index uint32
	Deal  *vss.Deal
}

type Response struct {
	// Index of the Dealer for which this response is for
	Index uint32

	Response *vss.Response
}

type Justification struct {
	// Index of the Dealer who answered with this Justification
	Index uint32

	Justification *vss.Justification
}

// SecretCommit is sent during the distributed public key reconstruction phase,
// basically a Feldman VSS scheme.
type SecretCommits struct {
	// SessionID generated by the Dealer
	SessionID []byte
	// Index of the Dealer in the list of participants
	Index uint32
	// Commitments generated by the Dealer
	Commitments []abstract.Point
	// Signature from the Dealer
	Signature []byte
}

type ComplaintCommits struct {
	// Index of the Verifier _issuing_ the ComplaintCommit
	Index uint32
	// DealerIndex being the index of the Dealer who issued the SecretCommits
	DealerIndex uint32
	// SessionID generated by the Dealer who issued the SecretCommits
	SessionID []byte
	// Signature made by the verifier
	Signature []byte
}

type DistKeyGenerator struct {
	suite abstract.Suite

	index uint32
	long  abstract.Scalar
	pub   abstract.Point

	participants []abstract.Point

	t int

	dealer    *vss.Dealer
	verifiers map[uint32]*vss.Verifier

	commitments map[uint32]*share.PubPoly
}

func NewDistKeyGenerator(suite abstract.Suite, longterm abstract.Scalar, participants []abstract.Point, r cipher.Stream, t int) (*DistKeyGenerator, error) {
	d := new(DistKeyGenerator)
	pub := suite.Point().Mul(nil, longterm)
	// find our index
	var found bool
	for i, p := range participants {
		if p.Equal(pub) {
			found = true
			d.index = uint32(i)
			break
		}
	}
	if !found {
		return nil, errors.New("dkg: own public key not found in list of participants")
	}
	var err error
	// generate our dealer / deal
	ownSec := suite.Scalar().Pick(r)
	d.dealer, err = vss.NewDealer(suite, longterm, ownSec, participants, r, t)
	if err != nil {
		return nil, err
	}
	// to receive the other deals
	d.verifiers = make(map[uint32]*vss.Verifier)
	d.t = t
	d.suite = suite
	d.long = longterm
	d.pub = pub
	d.participants = participants
	return d, nil
}

// DistDeals returns all the DistDeal that must be broadcasted to every
// participants. The DistDeal corresponding to this DKG is already added
// to this DKG and is ommitted from the returned map. To know
// to which participant to give the DistDeal, loop over the keys as indexes in
// the list of participants:
//   for i,dd := range distDeals {
//      sendTo(participants[i],dd)
//   }
//
func (d *DistKeyGenerator) Deals() map[int]*Deal {
	deals := d.dealer.Deals()
	dd := make(map[int]*Deal)
	for i := range d.participants {
		distd := &Deal{
			Index: d.index,
			Deal:  deals[i],
		}
		if i == int(d.index) {
			if _, err := d.ProcessDeal(distd); err != nil {
				panic(err)
			}
			continue
		}
		dd[i] = distd
	}
	return dd
}

func (d *DistKeyGenerator) ProcessDeal(dd *Deal) (*Response, error) {
	// public key of the dealer
	pub, ok := findPub(d.participants, dd.Index)
	if !ok {
		return nil, errors.New("dkg: dist deal out of bounds index")
	}

	if _, ok := d.verifiers[dd.Index]; ok {
		return nil, errors.New("dkg: already received dist deal from same index")
	}

	// verifier receiving the dealer's deal
	ver, err := vss.NewVerifier(d.suite, d.long, pub, d.participants)
	if err != nil {
		return nil, err
	}

	d.verifiers[dd.Index] = ver
	resp, err := ver.ProcessDeal(dd.Deal)
	return &Response{
		Index:    dd.Index,
		Response: resp,
	}, err
}

func (d *DistKeyGenerator) ProcessResponse(resp *Response) (*Justification, error) {
	v, ok := d.verifiers[resp.Index]
	if !ok {
		return nil, errors.New("dkg: complaint received but no deal for it")
	}

	if err := v.ProcessResponse(resp.Response); err != nil {
		return nil, err
	}

	// if we are processing a complaint for this d, return a justification and
	// process that justification for d's verifier
	if resp.Index == uint32(d.index) {
		j, err := d.dealer.ProcessResponse(resp.Response)
		if err := v.ProcessJustification(j); err != nil {
			panic(err)
		}
		return &Justification{
			Index:         d.index,
			Justification: j,
		}, err
	}
	return nil, nil
}

func (d *DistKeyGenerator) ProcessJustification(j *Justification) error {
	if v, ok := d.verifiers[j.Index]; !ok {
		return errors.New("dkg: Justification received but no deal for it")
	} else {
		return v.ProcessJustification(j.Justification)
	}
}

func (d *DistKeyGenerator) Certified() bool {
	var good int
	d.qualIter(func(v *vss.Verifier) { good++ })
	return good >= d.t
}

func (d *DistKeyGenerator) QUAL() []abstract.Point {
	var good []abstract.Point
	d.qualIter(func(v *vss.Verifier) {
		_, pub := v.Key()
		good = append(good, pub)
	})
	return good
}

func (d *DistKeyGenerator) isInQUAL(idx uint32) bool {
	var found bool
	d.qualIter(func(v *vss.Verifier) {
		if uint32(v.Index()) == idx {
			found = true
		}
	})
	return found
}

func (d *DistKeyGenerator) qualIter(fn func(v *vss.Verifier)) {
	for _, v := range d.verifiers {
		if v.EnoughApprovals() && v.DealCertified() {
			fn(v)
		}
	}
}

// Feldman VSS
func (d *DistKeyGenerator) SecretCommits() (*SecretCommits, error) {
	if !d.dealer.DealCertified() {
		return nil, errors.New("dkg: can't give SecretCommits if deal not certified")
	}
	sc := &SecretCommits{
		Commitments: d.dealer.Commits(),
		Index:       uint32(d.index),
		SessionID:   d.dealer.SessionID(),
	}
	msg := msgSecretCommit(sc)
	sig, err := sign.Schnorr(d.suite, d.long, msg)
	if err != nil {
		return nil, err
	}
	sc.Signature = sig
	// adding our own commitments
	d.commitments[uint32(d.index)] = share.NewPubPoly(d.suite, d.suite.Point().Base(), sc.Commitments)
	return sc, err
}

// Feldman VSS
func (d *DistKeyGenerator) ProcessSecretCommits(sc *SecretCommits) (*ComplaintCommits, error) {
	msg := msgSecretCommit(sc)
	pub, ok := findPub(d.participants, sc.Index)
	if !ok {
		return nil, errors.New("dkg: secretcommits received with index out of bounds")
	}

	if !d.isInQUAL(sc.Index) {
		return nil, errors.New("dkg: secretcommits from a non QUAL member")
	}

	if err := sign.VerifySchnorr(d.suite, pub, msg, sc.Signature); err != nil {
		return nil, err
	}

	v, ok := d.verifiers[sc.Index]
	if !ok {
		return nil, errors.New("dkg: secretcommits received without corresponding verifier")
	}
	if !bytes.Equal(v.SessionID(), sc.SessionID) {
		return nil, errors.New("dkg: secretcommits received with wrong session id")
	}
	deal := v.Deal()
	if d == nil {
		return nil, errors.New("dkg: secretcommits received but deal is not certified")
	}
	poly := share.NewPubPoly(d.suite, d.suite.Point().Base(), sc.Commitments)
	if !poly.Check(deal.SecShare) {
		cc := &ComplaintCommits{
			Index:       uint32(d.index),
			DealerIndex: sc.Index,
			SessionID:   sc.SessionID,
		}
		var err error
		msg := msgCommitComplaint(cc)
		if cc.Signature, err = sign.Schnorr(d.suite, d.long, msg); err != nil {
			return nil, err
		}
		return cc, nil
	}
	// commitments are fine
	d.commitments[sc.Index] = poly
	return nil, nil
}

func (d *DistKeyGenerator) ProcessCommitComplaint(cc *ComplaintCommits) (*vss.Deal, error) {
	issuer, ok := findPub(d.participants, cc.Index)
	if !ok {
		return nil, errors.New("dkg: commitcomplaint with unknown issuer")
	}
	if err := sign.VerifySchnorr(d.suite, issuer, msgCommitComplaint(cc), cc.Signature); err != nil {
		return nil, err
	}

	v, ok := d.verifiers[cc.DealerIndex]
	if !ok {
		return nil, errors.New("dkg: commitcomplaint linked to unknown verifier")
	}

	deal := v.Deal()
	if deal == nil {
		return nil, errors.New("dkg: commitcomplaint linked to non certified deal")
	}
	return deal, nil
}

// ProduceSharedSecret will generate the sharedsecret relative to this receiver
// it will throw an error if something is wrong such as not enough Dealers received
// The shared secret can be computed when all deals have been sent and
// basically consists of a
// 1. Public Polynomial which is basically the sums of all Dealers's polynomial
// 2. Share of the global Private Polynomial (which is to never be computed directly), which is
// 		basically SUM of fj(i) for a receiver i
func (d *DistKeyGenerator) DistKeyShare() (*DistKeyShare, error) {
	if !d.Certified() {
		return nil, errors.New("dkg: distributed key not certified")
	}

	sh := d.suite.Scalar().Zero()
	// share of dist. secret = sum of all share received.
	// Dist. public key = sum of all revealed commitments
	d.qualIter(func(v *vss.Verifier) {
		s := v.Deal().SecShare.V
		sh = sh.Add(sh, s)
	})

	secretShare := &share.PriShare{
		I: int(d.index),
		V: sh,
	}

	pub := d.commitments[uint32(d.index)]
	var err error
	for i, pp := range d.commitments {
		if i == uint32(d.index) {
			continue
		}
		pub, err = pub.Add(pp)
		if err != nil {
			return nil, err
		}
	}

	if !pub.Check(secretShare) {
		return nil, errors.New("dkg: share can't be verifie against commitments")
	}
	_, commits := pub.Info()
	return &DistKeyShare{
		Index:       int(d.index),
		Commitments: commits,
		Share:       secretShare.V,
	}, nil
}

func msgSecretCommit(sc *SecretCommits) []byte {
	var buf bytes.Buffer
	buf.WriteString("secretcommits")
	buf.Write(sc.SessionID)
	binary.Write(&buf, binary.LittleEndian, sc.Index)
	for _, p := range sc.Commitments {
		p.MarshalTo(&buf)
	}
	return buf.Bytes()
}

func msgCommitComplaint(cc *ComplaintCommits) []byte {
	var buf bytes.Buffer
	buf.WriteString("commitcomplaint")
	buf.Write(cc.SessionID)
	binary.Write(&buf, binary.LittleEndian, cc.Index)
	binary.Write(&buf, binary.LittleEndian, cc.DealerIndex)
	return buf.Bytes()
}

// XXX: maybe put that as internal package for vss & dkg since they both use the
// same function
func findPub(list []abstract.Point, i uint32) (abstract.Point, bool) {
	if i >= uint32(len(list)) {
		return nil, false
	}
	return list[i], true
}
