package vss

import (
	"bytes"
	"crypto/cipher"
	"encoding/binary"
	"errors"

	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/share"
	"github.com/dedis/crypto/sign"
)

type DistKeyShare struct {

	// the public key generated
	Public abstract.Point

	// share of the distributed secret
	Share abstract.Scalar

	// index of the participant holding this share
	Index int
}

// DistDeal is a simple wrapper around Deal used to provide the index of the
// Dealer in the list of participants together with its Deal.
// NOTE: Doing that in vss.go would be possible but then the Dealer is always
// assumed to be a member of the participants. It's only the case here.
type DistDeal struct {
	Index uint32
	Deal  *Deal
}

// SecretCommit is sent during the distributed public key reconstruction phase,
// basically a Feldman VSS scheme.
type SecretCommits struct {
	// SessionID generated by the Dealer
	SessionID []byte
	// Index of the Dealer in the list of participants
	Index uint32
	// Commitments generated by the Dealer
	Commitments []abstract.Point
	// Signature from the Dealer
	Signature []byte
}

type ComplaintCommits struct {
	// Index of the Verifier _issuing_ the ComplaintCommit
	Index uint32
	// DealerIndex being the index of the Dealer who issued the SecretCommits
	DealerIndex uint32
	// SessionID generated by the Dealer who issued the SecretCommits
	SessionID []byte
	// Signature made by the verifier
	Signature []byte
}

type DistKeyGenerator struct {
	suite abstract.Suite

	index uint32
	long  abstract.Scalar
	pub   abstract.Point

	participants []abstract.Point

	t int

	dealer    *Dealer
	verifiers map[uint32]*Verifier

	commitments map[uint32]*share.PubPoly
}

func NewDistKeyGeneration(suite abstract.Suite, longterm abstract.Scalar, participants []abstract.Point, r cipher.Stream, t int) (*DistKeyGenerator, error) {
	d := new(DistKeyGenerator)
	pub := suite.Point().Mul(nil, longterm)
	// find our index
	var found bool
	for i, p := range participants {
		if p.Equal(pub) {
			found = true
			d.index = uint32(i)
			break
		}
	}
	if !found {
		return nil, errors.New("dkg: own public key not found in list of participants")
	}
	var err error
	// generate our dealer / deal
	ownSec := suite.Scalar().Pick(r)
	d.dealer, err = NewDealer(suite, longterm, ownSec, participants, r, t)
	if err != nil {
		return nil, err
	}
	// to receive the other deals
	d.verifiers = make(map[uint32]*Verifier)
	d.t = t
	d.suite = suite
	d.long = longterm
	d.pub = pub
	d.participants = participants
	return d, nil
}

// DistDeals returns all the DistDeal that must be broadcasted to every
// participants. The DistDeal corresponding to this DKG is already added
// to this DKG and is ommitted from the returned slice. To know
// to which one to give the DistDeal, simply look the "Index" field.
func (d *DistKeyGenerator) DistDeal() []*DistDeal {
	deals := d.dealer.Deals()
	dd := make([]*DistDeal, len(deals))
	for i, deal := range deals {
		distd := &DistDeal{
			Index: d.index,
			Deal:  deal,
		}
		if i == int(d.index) {
			d.ProcessDistDeal(distd)
		}
	}
	return dd
}

func (d *DistKeyGenerator) ProcessDistDeal(dd *DistDeal) (*Approval, *Complaint, error) {
	pub, ok := findPub(d.participants, dd.Index)
	if !ok {
		return nil, nil, errors.New("dkg: dist deal out of bounds index")
	}
	if _, ok := d.verifiers[d.index]; ok {
		return nil, nil, errors.New("dkg: already received dist deal from same index")
	}

	ver, err := NewVerifier(d.suite, d.long, pub, d.participants)
	if err != nil {
		return nil, nil, err
	}

	d.verifiers[dd.Index] = ver
	return ver.ProcessDeal(dd.Deal)
}

func (d *DistKeyGenerator) ProcessApproval(ap *Approval) error {
	if v, ok := d.verifiers[ap.Index]; !ok {
		return errors.New("dkg: approval received but no deal for it")
	} else {
		return v.ProcessApproval(ap)
	}
}

func (d *DistKeyGenerator) ProcessComplaint(cp *Complaint) (*Justification, error) {
	if cp.Index == uint32(d.index) {
		return d.dealer.ProcessComplaint(cp)
	}
	if v, ok := d.verifiers[cp.Index]; !ok {
		return nil, errors.New("dkg: complaint received but no deal for it")
	} else {
		return nil, v.ProcessComplaint(cp)
	}
}

func (d *DistKeyGenerator) ProcessJustification(j *Justification) error {
	if v, ok := d.verifiers[j.Index]; !ok {
		return errors.New("dkg: Justification received but no deal for it")
	} else {
		return v.ProcessJustification(j)
	}
}

func (d *DistKeyGenerator) Certified() bool {
	var good int
	d.qualIter(func(v *Verifier) { good++ })
	return good >= d.t
}

func (d *DistKeyGenerator) QUAL() []abstract.Point {
	var good []abstract.Point
	d.qualIter(func(v *Verifier) {
		good = append(good, v.pub)
	})
	return good
}

func (d *DistKeyGenerator) isInQUAL(idx uint32) bool {
	var found bool
	d.qualIter(func(v *Verifier) {
		if uint32(v.index) == idx {
			found = true
		}
	})
	return found
}

func (d *DistKeyGenerator) qualIter(fn func(v *Verifier)) {
	for _, v := range d.verifiers {
		if v.EnoughApprovals() && v.DealCertified() {
			fn(v)
		}
	}
}

// Feldman VSS
func (d *DistKeyGenerator) SecretCommits() (*SecretCommits, error) {
	if !d.dealer.DealCertified() {
		return nil, errors.New("dkg: can't give SecretCommits if deal not certified")
	}
	sc := &SecretCommits{
		Commitments: d.dealer.Commits(),
		Index:       uint32(d.index),
		SessionID:   d.dealer.sessionID,
	}
	msg := msgSecretCommit(sc)
	sig, err := sign.Schnorr(d.suite, d.long, msg)
	if err != nil {
		return nil, err
	}
	sc.Signature = sig
	// adding our own commitments
	d.commitments[uint32(d.index)] = share.NewPubPoly(d.suite, d.suite.Point().Base(), sc.Commitments)
	return sc, err
}

// Feldman VSS
func (d *DistKeyGenerator) ProcessSecretCommits(sc *SecretCommits) (*ComplaintCommits, error) {
	msg := msgSecretCommit(sc)
	pub, ok := findPub(d.participants, sc.Index)
	if !ok {
		return nil, errors.New("dkg: secretcommits received with index out of bounds")
	}

	var found bool
	d.qualIter(func(v *Verifier) {
		if sc.Index == uint32(v.index) {
			found = true
		}
	})

	if !found {
		return nil, errors.New("dkg: secretcommits from a non QUAL member")
	}

	if err := sign.VerifySchnorr(d.suite, pub, msg, sc.Signature); err != nil {
		return nil, err
	}

	v, ok := d.verifiers[sc.Index]
	if !ok {
		return nil, errors.New("dkg: secretcommits received without corresponding verifier")
	}
	if !bytes.Equal(v.sid, sc.SessionID) {
		return nil, errors.New("dkg: secretcommits received with wrong session id")
	}
	deal := v.Deal()
	if d == nil {
		return nil, errors.New("dkg: secretcommits received but deal is not certified")
	}
	poly := share.NewPubPoly(d.suite, d.suite.Point().Base(), sc.Commitments)
	if !poly.Check(deal.SecShare) {
		cc := &ComplaintCommits{
			Index:       uint32(d.index),
			DealerIndex: sc.Index,
			SessionID:   sc.SessionID,
		}
		var err error
		msg := msgCommitComplaint(cc)
		if cc.Signature, err = sign.Schnorr(d.suite, d.long, msg); err != nil {
			return nil, err
		}
		return cc, nil
	}
	// commitments are fine
	d.commitments[sc.Index] = poly
	return nil, nil
}

func (d *DistKeyGenerator) ProcessCommitComplaint(cc *ComplaintCommits) (*Deal, error) {
	issuer, ok := findPub(d.participants, cc.Index)
	if !ok {
		return nil, errors.New("dkg: commitcomplaint with unknown issuer")
	}
	if err := sign.VerifySchnorr(d.suite, issuer, msgCommitComplaint(cc), cc.Signature); err != nil {
		return nil, err
	}

	v, ok := d.verifiers[cc.DealerIndex]
	if !ok {
		return nil, errors.New("dkg: commitcomplaint linked to unknown verifier")
	}

	deal := v.Deal()
	if deal == nil {
		return nil, errors.New("dkg: commitcomplaint linked to non certified deal")
	}
	return deal, nil
}

// ProduceSharedSecret will generate the sharedsecret relative to this receiver
// it will throw an error if something is wrong such as not enough Dealers received
// The shared secret can be computed when all deals have been sent and
// basically consists of a
// 1. Public Polynomial which is basically the sums of all Dealers's polynomial
// 2. Share of the global Private Polynomial (which is to never be computed directly), which is
// 		basically SUM of fj(i) for a receiver i
func (d *DistKeyGenerator) DistKeyShare() (*DistKeyShare, error) {
	if !d.Certified() {
		return nil, errors.New("dkg: distributed key not certified")
	}

	sh := d.suite.Scalar().Zero()
	// share of dist. secret = sum of all share received.
	// Dist. public key = sum of all revealed commitments
	d.qualIter(func(v *Verifier) {
		s := v.Deal().SecShare.V
		sh = sh.Add(sh, s)
	})

	secretShare := &share.PriShare{
		I: int(d.index),
		V: sh,
	}

	pub := d.commitments[uint32(d.index)]
	var err error
	for i, pp := range d.commitments {
		if i == uint32(d.index) {
			continue
		}
		pub, err = pub.Add(pp)
		if err != nil {
			return nil, err
		}
	}

	if !pub.Check(secretShare) {
		return nil, errors.New("dkg: share can't be verifie against commitments")
	}

	return &DistKeyShare{
		Index:  int(d.index),
		Public: pub.Commit(),
		Share:  secretShare.V,
	}, nil
}

func msgSecretCommit(sc *SecretCommits) []byte {
	var buf bytes.Buffer
	buf.WriteString("secretcommits")
	buf.Write(sc.SessionID)
	binary.Write(&buf, binary.LittleEndian, sc.Index)
	for _, p := range sc.Commitments {
		p.MarshalTo(&buf)
	}
	return buf.Bytes()
}

func msgCommitComplaint(cc *ComplaintCommits) []byte {
	var buf bytes.Buffer
	buf.WriteString("commitcomplaint")
	buf.Write(cc.SessionID)
	binary.Write(&buf, binary.LittleEndian, cc.Index)
	binary.Write(&buf, binary.LittleEndian, cc.DealerIndex)
	return buf.Bytes()
}
